// Generated by CoffeeScript 1.3.3
(function() {
  var EventEmitter, Getbot, fs, http, nodeFS, os, path, request, url, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = require('util');

  fs = require('fs');

  path = require('path');

  http = require('http');

  url = require('url');

  os = require('os');

  request = require('request');

  nodeFS = require('node-fs');

  EventEmitter = require('events').EventEmitter;

  Getbot = (function(_super) {

    __extends(Getbot, _super);

    function Getbot(opts) {
      this.startParts = __bind(this.startParts, this);

      this.download = __bind(this.download, this);

      this.openFile = __bind(this.openFile, this);

      this.prepareFile = __bind(this.prepareFile, this);

      var req,
        _this = this;
      this.destination = opts.destination;
      this.forceOverwrite = opts.force;
      this.maxConnections = opts.connections;
      this.listDownload = opts.listDownload;
      this.statusCode = null;
      this.reqOptions = {
        uri: opts.address,
        auth: opts.pass ? "" + opts.user + ":" + opts.pass : void 0
      };
      this.started = false;
      this.partsCompleted = 0;
      req = request.head(this.reqOptions, function(error, response, body) {
        if (!error) {
          switch (response.statusCode) {
            case 200:
              _this.statusCode = response.statusCode;
              if (response.headers['content-length'] !== void 0 && response.headers['content-length'] !== 0) {
                if (!response.headers['accept-ranges'] || response.headers['accept-ranges'] !== "bytes") {
                  _this.emit('noresume', response.statusCode);
                  _this.maxConnections = 1;
                }
                _this.fileName = decodeURI(response.request.uri.pathname.split("/").pop());
                _this.fileSize = response.headers['content-length'];
                _this.downloadStart = new Date;
                _this.totalDownloaded = 0;
                return _this.prepareFile(_this.fileName);
              } else {
                return _this.emit('error', "content-length is " + response.headers['content-length'] + ", aborting...");
              }
              break;
            case 400:
              return _this.emit('error', "400 Bad Request");
            case 401:
              return _this.emit('error', "401 Unauthorized");
            default:
              return _this.emit('error', "" + response.statusCode);
          }
        } else {
          return _this.emit('error', "" + error);
        }
      });
      req.end();
    }

    Getbot.prototype.prepareFile = function(fileName) {
      var isFolder,
        _this = this;
      if (this.destination) {
        if (this.destination.charAt(this.destination.length - 1) === '/') {
          isFolder = true;
        }
        this.startPath = process.cwd();
        this.path = null;
        if (!isFolder) {
          this.fileExt = path.extname(this.destination);
          this.fileBasename = path.basename(this.destination, this.fileExt);
        } else {
          this.fileExt = path.extname(fileName);
          this.fileBasename = path.basename(fileName, this.fileExt);
        }
        return fs.exists(this.destination, function(exists) {
          if (exists && isFolder) {
            return _this.openFile(_this.destination);
          } else if (isFolder) {
            return nodeFS.mkdir(_this.destination, 0x1ff, true, function() {
              return _this.openFile(_this.destination);
            });
          } else {
            _this.path = path.dirname(_this.destination);
            if (_this.path !== _this.startPath) {
              return nodeFS.mkdir(_this.path, 0x1ff, true, function() {
                return _this.openFile(_this.path);
              });
            } else {
              return _this.openFile(_this.path);
            }
          }
        });
      } else {
        this.fileExt = path.extname(fileName);
        this.fileBasename = path.basename(fileName, this.fileExt);
        return this.openFile(process.cwd());
      }
    };

    Getbot.prototype.openFile = function(path) {
      var _this = this;
      try {
        process.chdir(path);
      } catch (error) {
        this.emit('error', error);
      }
      this.fileName = this.origFilename = "" + this.fileBasename + this.fileExt;
      this.newFilename = "" + this.origFilename + ".getbot";
      return fs.exists(this.fileName, function(exists) {
        var msg;
        if (exists) {
          if (!_this.forceOverwrite) {
            msg = _this.destination ? "" + _this.destination + _this.fileName : "" + _this.fileName;
            _this.emit('fileExists', msg);
          }
        }
        return fs.open(_this.newFilename, 'w', function(err, fd) {
          return fs.truncate(fd, _this.fileSize, function() {
            return _this.startParts(_this.reqOptions, _this.fileSize, _this.maxConnections, _this.download);
          });
        });
      });
    };

    Getbot.prototype.download = function(options, offset, end, number) {
      var file, fops, partNumber, req,
        _this = this;
      options.method = 'GET';
      options.headers = {};
      options.headers["range"] = "bytes=" + offset + "-" + end;
      options.headers['user-agent'] = "Getbot.js/" + options.version + " (" + (os.type()) + "/" + (os.release()) + ";" + (os.arch()) + " like wget);";
      options.onResponse = true;
      options.pool = {};
      options.pool['maxSockets'] = this.maxConnections;
      partNumber = number;
      fops = {
        flags: 'r+',
        start: offset
      };
      file = fs.createWriteStream(this.newFilename, fops);
      return req = request.get(options, function(error, response) {
        if (error) {
          this.emit('error', error);
        }
        return this.emit('downloadStart', this.statusCode);
      }).on('data', function(data) {
        _this.totalDownloaded += data.length;
        _this.rate = _this.downloadRate(_this.downloadStart);
        file.write(data);
        if (!_this.started) {
          _this.emit('downloadStart', _this.statusCode);
          if (_this.started === false) {
            _this.started = true;
          }
        }
        return _this.emit('data', data, _this.rate);
      }).on('end', function() {
        _this.partsCompleted++;
        _this.emit('partComplete', partNumber);
        if (_this.partsCompleted === _this.maxConnections) {
          file.end();
          return fs.rename(_this.newFilename, _this.origFilename, function() {
            if (_this.destination && _this.listDownload) {
              process.chdir(_this.startPath);
            }
            return _this.emit('allPartsComplete');
          });
        }
      });
    };

    Getbot.prototype.downloadRate = function(start) {
      return this.totalDownloaded / (new Date - start) * 1024;
    };

    Getbot.prototype.startParts = function(options, bytes, parts, callback) {
      var i, partSize, _results;
      partSize = Math.ceil(1 * bytes / parts);
      i = 0;
      _results = [];
      while (i < parts) {
        callback(options, partSize * i, Math.min(partSize * (i + 1) - 1, bytes - 1), i + 1);
        i++;
        _results.push(this.emit('startPart', i));
      }
      return _results;
    };

    return Getbot;

  })(EventEmitter);

  module.exports = Getbot;

}).call(this);
