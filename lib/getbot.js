// Generated by CoffeeScript 1.3.3
(function() {
  var EventEmitter, Getbot, fs, http, path, request, url, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  util = require('util');

  fs = require('node-fs');

  path = require('path');

  http = require('http');

  url = require('url');

  request = require('request');

  EventEmitter = require('events').EventEmitter;

  Getbot = (function(_super) {

    __extends(Getbot, _super);

    function Getbot(opts) {
      this.startParts = __bind(this.startParts, this);

      this.download = __bind(this.download, this);

      var options, req,
        _this = this;
      this.destination = opts.destination;
      this.maxConnections = opts.connections;
      options = {
        uri: opts.address,
        headers: {},
        method: 'HEAD'
      };
      if (!options.auth) {
        options.auth = "" + opts.user + ":" + opts.pass;
      }
      this.partsCompleted = 0;
      if (this.destination) {
        this.filename = this.destination;
        this.path = path.dirname(this.destination);
        if (this.path) {
          this.startPath = process.cwd();
          fs.mkdir(this.path, 0x1ff, true, function() {
            return process.chdir(_this.path);
          });
        }
      } else {
        this.filename = decodeURI(url.parse(opts.address).pathname.split("/").pop());
      }
      this.fileExt = path.extname(this.filename);
      this.fileBasename = path.basename(this.filename, this.fileExt);
      this.fileDirname = path.dirname(this.filename);
      this.origFilename = "" + this.fileBasename + this.fileExt;
      this.newFilename = "" + this.origFilename + ".getbot";
      req = request(options, function(error, response, body) {
        if (!error) {
          switch (response.statusCode) {
            case 200:
              if (response.headers['content-length'] !== void 0 && response.headers['content-length'] !== 0) {
                if (!response.headers['accept-ranges'] || response.headers['accept-ranges'] !== "bytes") {
                  _this.emit('noresume', response.statusCode);
                  _this.maxConnections = 1;
                }
                _this.fileSize = response.headers['content-length'];
                _this.downloadStart = new Date;
                _this.totalDownloaded = 0;
                try {
                  _this.emit('downloadStart', "" + response.statusCode);
                  return fs.open(_this.newFilename, 'w', function(err, fd) {
                    fs.truncate(fd, _this.fileSize);
                    return _this.startParts(options, _this.fileSize, _this.maxConnections, _this.download);
                  });
                } catch (error) {
                  return _this.emit('error', error);
                }
              } else {
                return _this.emit('error', "content-length is " + response.headers['content-length'] + ", aborting...");
              }
              break;
            case 400:
              return _this.emit('error', "400 Bad Request");
            case 401:
              return _this.emit('error', "401 Unauthorized");
            default:
              return _this.emit('error', "" + response.statusCode);
          }
        } else {
          return _this.emit('error', "" + error);
        }
      });
      req.end();
    }

    Getbot.prototype.download = function(options, offset, end, number) {
      var file, fops, partNumber, req,
        _this = this;
      options.headers = {};
      options.pool = {};
      options.method = 'GET';
      options.headers["range"] = "bytes=" + offset + "-" + end;
      options.onResponse = true;
      options.pool['maxSockets'] = this.maxConnections;
      partNumber = number;
      fops = {
        flags: 'r+',
        start: offset
      };
      file = fs.createWriteStream(this.newFilename, fops);
      return req = request(options, function(error, response) {
        if (error) {
          return this.emit('error', error);
        }
      }).on('data', function(data) {
        var rate;
        _this.totalDownloaded += data.length;
        rate = _this.downloadRate(_this.downloadStart);
        file.write(data);
        _this.emit('data', data, rate);
      }).on('end', function() {
        _this.partsCompleted++;
        _this.emit('partComplete', partNumber);
        if (_this.partsCompleted === _this.maxConnections) {
          file.end();
          return fs.rename(_this.newFilename, _this.origFilename, function() {
            if (_this.destination && _this.listDownload) {
              process.chdir(_this.startPath);
            }
            return _this.emit('allPartsComplete');
          });
        }
      });
    };

    Getbot.prototype.downloadRate = function(start) {
      return this.totalDownloaded / (new Date - start) * 1024;
    };

    Getbot.prototype.startParts = function(options, bytes, parts, callback) {
      var i, partSize, _results;
      partSize = Math.ceil(1 * bytes / parts);
      i = 0;
      _results = [];
      while (i < parts) {
        callback(options, partSize * i, Math.min(partSize * (i + 1) - 1, bytes - 1), i + 1);
        i++;
        _results.push(this.emit('startPart', i));
      }
      return _results;
    };

    return Getbot;

  })(EventEmitter);

  module.exports = Getbot;

}).call(this);
